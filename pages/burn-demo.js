// Generated by CoffeeScript 1.9.2
var pickOne, randomProjection;

pickOne = function(choices) {
  return choices[Math.floor(Math.random() * choices.length)];
};

randomProjection = function(startIndex, startY, target, slopes) {
  var i, series, y;
  series = [];
  i = 0;
  while (i < startIndex) {
    i++;
    series.push(null);
  }
  y = startY;
  while (y < target) {
    series.push(y);
    y += pickOne(slopes);
    i++;
  }
  series.push(y);
  return {
    series: series,
    index: i
  };
};

Polymer({
  is: "burn-demo",
  ready: function() {
    var lastStep;
    this.gestureActive = true;
    this.step = 0;
    lastStep = 20;
    return this.steps = Array(lastStep + 1);
  },
  properties: {
    step: {
      type: Number,
      observer: 'stepChanged'
    },
    chartConfig: Object,
    dialog: String,
    steps: Array
  },
  stepChanged: function(step, oldStep) {
    var config, currentPrerequisites, dialog, extractPrerequisites, i, j, len, nl, slopes, startIndex, startY, steps, target;
    if (oldStep == null) {
      oldStep = 0;
    }
    config = {};
    slopes = startIndex = startY = target = null;
    nl = null;
    steps = [
      {
        dialog: "This is what your burn-up chart looks like on day 1.",
        f: function() {
          return config = {
            periods: 20
          };
        }
      }, {
        dialog: "5 time periods laters, we'll have some data. The slope (rise) of the segment indicates the velocity or throughput for that time period.",
        f: function() {
          return config.burnSeries = [0, 1, 8, 11, 19, 21];
        }
      }, {
        dialog: "Scope data added. It's pretty much leveled off.",
        f: function() {
          return config.scopeSeries = [37, 42, 44, 44, 47, 48];
        }
      }, {
        dialog: "So, it's reasonable to assume that it will not grow the rest of the project.",
        f: function() {
          return config.scopeProjection = [nl, nl, nl, nl, nl, 48, nl, nl, nl, nl, nl, nl, nl, nl, nl, nl, nl, nl, nl, nl, 48];
        }
      }, {
        dialog: "Traditional linear forecast identifies one date, but that's only one possible outcome.",
        f: function() {
          return config.linearProjection = [0, nl, nl, nl, nl, 21, nl, nl, nl, nl, nl, nl, 48];
        }
      }, {
        dialog: "Pretend we have a 5-sided dice, where 1=1st slope (velocity/throughput), 2=2nd slope, etc. We get unlucky and roll a 5 corresponding the shallow slope (low throughput/velocity) of the last time period.",
        f: function() {
          return config.forecastProjections = [[nl, nl, nl, nl, nl, 21, 22.9]];
        }
      }, {
        dialog: "Unlucky again!",
        f: function() {
          return config.forecastProjections = [[nl, nl, nl, nl, nl, 21, 22.9, 24.8]];
        }
      }, {
        dialog: "Unlucky 14 times in a row!!! Notice, the first blue tick mark where it hits the scope line.",
        f: function() {
          var i, j, ref;
          config.forecastProjections = [[nl, nl, nl, nl, nl, 21, 22.9, 24.8, 26.7, 28.6, 30.5, 32.4, 34.3, 36.2, 38.1, 40, 41.9, 43.9, 45.9, 48, nl]];
          config.histogram = [];
          for (i = j = 0, ref = config.periods; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
            config.histogram.push(0);
          }
          return config.histogram[20] = 1;
        }
      }, {
        dialog: "Now we roll a 4 corresponding the highest slope/velocity/throughput.",
        f: function() {
          return config.forecastProjections = [[nl, nl, nl, nl, nl, 21, 22.9, 24.8, 26.7, 28.6, 30.5, 32.4, 34.3, 36.2, 38.1, 40, 41.9, 43.9, 45.9, 48, nl], [nl, nl, nl, nl, nl, 21, 30]];
        }
      }, {
        dialog: "Yippie! Rolled another 4!",
        f: function() {
          return config.forecastProjections = [[nl, nl, nl, nl, nl, 21, 22.9, 24.8, 26.7, 28.6, 30.5, 32.4, 34.3, 36.2, 38.1, 40, 41.9, 43.9, 45.9, 48, nl], [nl, nl, nl, nl, nl, 21, 30, 39]];
        }
      }, {
        dialog: "Another 4?!?! We're going to Vegas!!!",
        f: function() {
          config.forecastProjections = [[nl, nl, nl, nl, nl, 21, 22.9, 24.8, 26.7, 28.6, 30.5, 32.4, 34.3, 36.2, 38.1, 40, 41.9, 43.9, 45.9, 48, nl], [nl, nl, nl, nl, nl, 21, 30, 39, 48]];
          return config.histogram[8] = 1;
        }
      }, {
        dialog: "But we're not always going to be either lucky or unlucky. We're just as likely to roll a 1, 2, or 3 as we are a 5 or 4. Each set of rolls is another possible forecast. Here's one.",
        f: function() {
          var j, len, point, priorPoint, projection, ref;
          slopes = [];
          priorPoint = null;
          ref = config.burnSeries;
          for (j = 0, len = ref.length; j < len; j++) {
            point = ref[j];
            if (priorPoint != null) {
              slopes.push(point - priorPoint);
            }
            priorPoint = point;
          }
          startIndex = config.burnSeries.length - 1;
          startY = config.burnSeries[startIndex];
          target = config.scopeSeries[startIndex];
          projection = randomProjection(startIndex, startY, target, slopes);
          config.forecastProjections.push(projection.series);
          return config.histogram[projection.index]++;
        }
      }, {
        dialog: "Here's five more sets of dice rolls, each representing another possible outcome. Notice the histogram growing up top.",
        f: function() {
          var i, j, projection, results;
          results = [];
          for (i = j = 1; j <= 5; i = ++j) {
            projection = randomProjection(startIndex, startY, target, slopes);
            config.forecastProjections.push(projection.series);
            results.push(config.histogram[projection.index]++);
          }
          return results;
        }
      }, {
        dialog: 'What if we roll a few dozen forecasts? Not a smooth curve, but informative.',
        f: function() {
          var h, i, j, len, max, multiplier, projection, ref, results;
          max = 0;
          multiplier = .5;
          while (max < 35 * multiplier) {
            projection = randomProjection(startIndex, startY, target, slopes);
            config.forecastProjections.push(projection.series);
            config.histogram[projection.index]++;
            max = Math.max(config.histogram[projection.index], max);
          }
          ref = config.histogram;
          results = [];
          for (i = j = 0, len = ref.length; j < len; i = ++j) {
            h = ref[i];
            results.push(config.histogram[i] = h / multiplier);
          }
          return results;
        }
      }, {
        dialog: "What if we roll hundreds of forecasts? It's starting to smooth out. It would be very smooth at thousands.",
        f: function() {
          var h, i, j, len, max, multiplier, projection, ref, results;
          max = 0;
          multiplier = 5;
          while (max < 35 * multiplier) {
            projection = randomProjection(startIndex, startY, target, slopes);
            config.forecastProjections.push(projection.series);
            config.histogram[projection.index]++;
            max = Math.max(config.histogram[projection.index], max);
          }
          ref = config.histogram;
          results = [];
          for (i = j = 0, len = ref.length; j < len; i = ++j) {
            h = ref[i];
            results.push(config.histogram[i] = h / multiplier);
          }
          return results;
        }
      }, {
        prerequisites: [0, 1, 2],
        dialog: "Let's start over, except this time, let's assume there is a 50% likely risk that will delay the project between 5 and 7 time periods.",
        f: function() {
          var i, j, k, ref, ref1, ref2;
          config.periods = 28;
          config.scopeProjection = [];
          startIndex = config.burnSeries.length - 1;
          target = config.scopeSeries[startIndex];
          for (i = j = 0, ref = config.scopeSeries.length - 2; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
            config.scopeProjection.push(null);
          }
          config.scopeProjection.push(target);
          for (i = k = ref1 = config.scopeProjection.length + 1, ref2 = config.periods; ref1 <= ref2 ? k <= ref2 : k >= ref2; i = ref1 <= ref2 ? ++k : --k) {
            config.scopeProjection.push(null);
          }
          return config.scopeProjection.push(target);
        }
      }, {
        dialog: "Notice how the distribution is bimodal and the peaks are 6 time periods (average of 5, 6, and 7) apart.",
        f: function() {
          var adjustedStartIndex, delay, h, i, j, k, l, len, len1, max, multiplier, point, priorPoint, projection, ref, ref1, ref2, results;
          max = 0;
          multiplier = 5;
          config.forecastProjections = [];
          config.histogram = [];
          for (i = j = 0, ref = config.periods; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
            config.histogram.push(0);
          }
          startIndex = config.burnSeries.length - 1;
          startY = config.burnSeries[startIndex];
          target = config.scopeSeries[startIndex];
          slopes = [];
          priorPoint = null;
          ref1 = config.burnSeries;
          for (k = 0, len = ref1.length; k < len; k++) {
            point = ref1[k];
            if (priorPoint != null) {
              slopes.push(point - priorPoint);
            }
            priorPoint = point;
          }
          while (max < 35 * multiplier) {
            if (Math.random() < 0.5) {
              delay = 5 + Math.floor(Math.random() * 3);
              adjustedStartIndex = startIndex + delay;
            } else {
              adjustedStartIndex = startIndex;
            }
            projection = randomProjection(adjustedStartIndex, startY, target, slopes);
            config.forecastProjections.push(projection.series);
            config.histogram[projection.index]++;
            max = Math.max(config.histogram[projection.index], max);
          }
          ref2 = config.histogram;
          results = [];
          for (i = l = 0, len1 = ref2.length; l < len1; i = ++l) {
            h = ref2[i];
            results.push(config.histogram[i] = h / multiplier);
          }
          return results;
        }
      }, {
        prerequisites: [0, 1, 2],
        dialog: "A 50% risk is not very realistic. Let's see how it would look with a 20% risk and a 10% risk but with larger potential delay.",
        f: function() {
          var i, j, k, ref, ref1, ref2;
          config.periods = 33;
          config.scopeProjection = [];
          startIndex = config.burnSeries.length - 1;
          target = config.scopeSeries[startIndex];
          for (i = j = 0, ref = config.scopeSeries.length - 2; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
            config.scopeProjection.push(null);
          }
          config.scopeProjection.push(target);
          for (i = k = ref1 = config.scopeProjection.length + 1, ref2 = config.periods; ref1 <= ref2 ? k <= ref2 : k >= ref2; i = ref1 <= ref2 ? ++k : --k) {
            config.scopeProjection.push(null);
          }
          return config.scopeProjection.push(target);
        }
      }, {
        dialog: "Things get pretty messy and spread out.",
        f: function() {
          var adjustedStartIndex, h, i, j, k, l, len, len1, max, multiplier, point, priorPoint, projection, ref, ref1, ref2, results;
          max = 0;
          multiplier = 5;
          config.forecastProjections = [];
          config.histogram = [];
          for (i = j = 0, ref = config.periods; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
            config.histogram.push(0);
          }
          startIndex = config.burnSeries.length - 1;
          startY = config.burnSeries[startIndex];
          target = config.scopeSeries[startIndex];
          slopes = [];
          priorPoint = null;
          ref1 = config.burnSeries;
          for (k = 0, len = ref1.length; k < len; k++) {
            point = ref1[k];
            if (priorPoint != null) {
              slopes.push(point - priorPoint);
            }
            priorPoint = point;
          }
          while (max < 35 * multiplier) {
            adjustedStartIndex = startIndex;
            if (Math.random() < 0.2) {
              adjustedStartIndex += 5 + Math.floor(Math.random() * 3);
            }
            if (Math.random() < 0.1) {
              adjustedStartIndex += 10 + Math.floor(Math.random() * 3);
            }
            projection = randomProjection(adjustedStartIndex, startY, target, slopes);
            config.forecastProjections.push(projection.series);
            config.histogram[projection.index]++;
            max = Math.max(config.histogram[projection.index], max);
          }
          ref2 = config.histogram;
          results = [];
          for (i = l = 0, len1 = ref2.length; l < len1; i = ++l) {
            h = ref2[i];
            results.push(config.histogram[i] = h / multiplier);
          }
          return results;
        }
      }
    ];
    this.steps = steps;
    extractPrerequisites = function(steps, stepNumber, currentList) {
      var currentStep;
      if (currentList == null) {
        currentList = [];
      }
      currentStep = steps[stepNumber];
      currentList.unshift(stepNumber);
      if (currentStep.prerequisites != null) {
        currentList = currentStep.prerequisites.concat(currentList);
        return currentList;
      } else if (stepNumber === 0) {
        return currentList;
      } else {
        return extractPrerequisites(steps, stepNumber - 1, currentList);
      }
    };
    currentPrerequisites = extractPrerequisites(steps, step);
    for (j = 0, len = currentPrerequisites.length; j < len; j++) {
      i = currentPrerequisites[j];
      steps[i].f();
    }
    this.chartConfig = config;
    dialog = steps[step].dialog;
    if (dialog != null) {
      this.dialog = dialog;
      return this.$.intro.open();
    } else {
      return this.$.intro.close();
    }
  },
  _listTap: function() {
    return this.$.drawerPanel.closeDrawer();
  },
  forward: function() {
    if (this.step < this.steps.length - 1 && this.gestureActive) {
      this.gestureActive = false;
      this.step++;
      return setTimeout(this.enableGesture, 100);
    }
  },
  back: function() {
    if (this.step > 0 && this.gestureActive) {
      this.gestureActive = false;
      this.step--;
      return setTimeout(this.enableGesture, 100);
    }
  },
  enableGesture: function() {
    return document.querySelector('burn-demo').gestureActive = true;
  }
});
