// Generated by CoffeeScript 1.9.2
var Line, LineSeries, Rect, Tag, delay, rootAttributes,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

delay = function(m, f) {
  return setTimeout(f, m);
};

Tag = (function() {
  function Tag(tagType, tagAttributes, parent, tagText) {
    this.tagType = tagType;
    this.tagAttributes = tagAttributes;
    this.parent = parent != null ? parent : null;
    this.tagText = tagText != null ? tagText : null;
    if (!(this instanceof Tag)) {
      return new Tag(this.tagType, this.tagAttributes, this.parent, this.tagText);
    }
    this.children = [];
    if (this.parent != null) {
      if (this.parent.tagText != null) {
        throw new Error('Text and chilren on same element unsupported at this time');
      } else {
        this.parent.children.push(this);
        this.level = this.parent.level + 1;
      }
    } else {
      this.level = 0;
    }
  }

  Tag.camelToDash = function(str) {
    return str.replace(/\W+/g, "-").replace(/([a-z\d])([A-Z])/g, "$1-$2").toLowerCase();
  };

  Tag.prototype.tagOpenString = function() {
    var dashedKey, key, ref, s, value;
    s = "<" + this.tagType;
    ref = this.tagAttributes;
    for (key in ref) {
      value = ref[key];
      dashedKey = Tag.camelToDash(key);
      s += " " + dashedKey + "=\"" + (value.toString()) + "\"";
    }
    s += '>';
    return s;
  };

  Tag.prototype.tagCloseString = function() {
    return "</" + this.tagType + ">";
  };

  Tag.prototype.toString = function() {
    var c, j, len, ref, s;
    s = Array(this.level + 1).join('  ') + this.tagOpenString();
    if (this.tagText != null) {
      s += this.tagText.toString();
    } else if (this.children.length > 0) {
      ref = this.children;
      for (j = 0, len = ref.length; j < len; j++) {
        c = ref[j];
        s += '\n' + c.toString();
      }
      s += '\n' + Array(this.level + 1).join('  ');
    }
    s += this.tagCloseString();
    return s;
  };

  return Tag;

})();

Line = (function(superClass) {
  extend(Line, superClass);

  Line.defaultAttributes = {
    stroke: 'black',
    "stroke-width": 1,
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  };

  function Line(x1, y1, x2, y2, tagAttributes, parent) {
    var key, ref, value;
    this.tagAttributes = tagAttributes != null ? tagAttributes : {};
    this.parent = parent != null ? parent : null;
    this.tagAttributes.x1 = x1 + "%";
    this.tagAttributes.y1 = y1 + "%";
    this.tagAttributes.x2 = x2 + "%";
    this.tagAttributes.y2 = y2 + "%";
    if (Line.defaultAttributes != null) {
      ref = Line.defaultAttributes;
      for (key in ref) {
        value = ref[key];
        this.tagAttributes[key] = value;
      }
    }
    return Line.__super__.constructor.call(this, 'line', this.tagAttributes, this.parent);
  }

  Line.setDefaultAttributes = function(newOrOverideAttributes) {
    var key, results, value;
    results = [];
    for (key in newOrOverideAttributes) {
      value = newOrOverideAttributes[key];
      results.push(this.defaultAttributes[key] = value);
    }
    return results;
  };

  return Line;

})(Tag);

LineSeries = (function(superClass) {
  extend(LineSeries, superClass);

  function LineSeries(x0, y0, periodWidth, series, tagAttributes, parent) {
    var i, line, lineSeries, point, x, x1, x2, y1, y2;
    this.tagAttributes = tagAttributes != null ? tagAttributes : {};
    this.parent = parent != null ? parent : null;
    if (series == null) {
      return;
    }
    lineSeries = Tag('g', this.tagAttributes, this.parent);
    x = x0;
    if (series != null) {
      i = 0;
      while ((series[i] == null) && i < series.length) {
        x += periodWidth;
        i++;
      }
      x1 = x;
      y1 = y0 - series[i];
      i++;
      x += periodWidth;
      while (i < series.length) {
        point = series[i];
        if (point != null) {
          x2 = x;
          y2 = y0 - point;
          line = Line(x1, y1, x2, y2, null, lineSeries);
          x1 = x2;
          y1 = y2;
        }
        x += periodWidth;
        i++;
      }
    }
    return lineSeries;
  }

  return LineSeries;

})(Tag);

Rect = (function(superClass) {
  extend(Rect, superClass);

  function Rect(x, y, width, height, tagAttributes, parent) {
    this.tagAttributes = tagAttributes != null ? tagAttributes : {};
    this.parent = parent != null ? parent : null;
    this.tagAttributes.x = x + "%";
    this.tagAttributes.y = y + "%";
    this.tagAttributes.width = width + "%";
    this.tagAttributes.height = height + "%";
    return Rect.__super__.constructor.call(this, 'rect', this.tagAttributes, this.parent);
  }

  return Rect;

})(Tag);

rootAttributes = {
  id: 'burn-chart-svg',
  xmlns: "http://www.w3.org/2000/svg",
  width: '100%',
  height: '100%',
  'xmlns:xlink': "http://www.w3.org/1999/xlink",
  preserveAspectRatio: "none"
};

Polymer({
  is: "burn-chart",
  properties: {

    /*
    periods: Number
    burnSeries: Array
    scopeSeries: Array
    linearProjection: Array
    forecastProjections: Array  # Actually and Array of Arrays but I'll add an entire row at a time
    histogram: Array
     */
    config: {
      type: Object,
      observer: 'gotNewConfig'
    }
  },
  created: function() {},
  gotNewConfig: function(newValue, oldConfig1) {
    var attributes, root;
    this.oldConfig = oldConfig1;
    window.burnChartConfig = newValue;
    attributes = rootAttributes;
    root = Tag('svg', attributes);
    this.innerHTML = root;
    return this.async(this.drawVisualization2, 1);
  },
  drawVisualization2: function() {
    var attributes, bottomChartBottom, bottomChartHeight, bottomChartTop, bottomChartXAxis, bottomChartYAxis, bottomMargin, burnChartSVG, chartLeft, chartRight, chartWidth, dimensions, index, j, k, leftMargin, len, len1, lowerChart, oldConfig, periodWidth, point, priorX, ref, ref1, rightMargin, root, series, spaceBetween, topChartBottom, topChartHeight, topChartTop, topMargin, upperChart, x, x0, y0;
    oldConfig = window.oldBurnChartConfig;
    burnChartSVG = document.getElementById('burn-chart-svg');
    dimensions = {
      x: burnChartSVG.x.baseVal.value,
      y: burnChartSVG.y.baseVal.value,
      width: burnChartSVG.width.baseVal.value,
      height: burnChartSVG.height.baseVal.value
    };
    if (dimensions.width === 0 || dimensions.height === 0) {
      return this.async(this.drawVisualization2, 1);
    } else {
      Line.setDefaultAttributes({
        'stroke-width': 4
      });
      leftMargin = 10;
      rightMargin = 5;
      topMargin = 5;
      bottomMargin = 10;
      spaceBetween = 0;
      topChartHeight = 35;
      bottomChartHeight = 50;
      chartLeft = leftMargin;
      chartRight = 100 - rightMargin;
      chartWidth = chartRight - chartLeft;
      topChartTop = topMargin;
      topChartBottom = topChartTop + topChartHeight;
      bottomChartTop = topChartBottom + spaceBetween;
      bottomChartBottom = bottomChartTop + bottomChartHeight;
      attributes = rootAttributes;
      root = Tag('svg', attributes);
      lowerChart = Tag('g', {
        id: 'lower-chart'
      }, root);
      Line.setDefaultAttributes({
        stroke: 'black',
        'stroke-dasharray': "1,0"
      });
      bottomChartXAxis = Line(chartLeft, bottomChartBottom, chartRight, bottomChartBottom, null, lowerChart);
      bottomChartYAxis = Line(chartLeft, bottomChartBottom, chartLeft, bottomChartTop, null, lowerChart);
      periodWidth = chartWidth / this.config.periods;
      x0 = chartLeft;
      y0 = bottomChartBottom;
      Line.setDefaultAttributes({
        stroke: 'red'
      });
      LineSeries(x0, y0, periodWidth, this.config.burnSeries, null, lowerChart);
      Line.setDefaultAttributes({
        stroke: 'green'
      });
      LineSeries(x0, y0, periodWidth, this.config.scopeSeries, null, lowerChart);
      Line.setDefaultAttributes({
        'stroke-dasharray': "5,7"
      });
      LineSeries(x0, y0, periodWidth, this.config.scopeProjection, null, lowerChart);
      Line.setDefaultAttributes({
        stroke: 'blue'
      });
      LineSeries(x0, y0, periodWidth, this.config.linearProjection, null, lowerChart);
      Line.setDefaultAttributes({
        stroke: 'orange'
      });
      if (this.config.forecastProjections != null) {
        ref = this.config.forecastProjections;
        for (j = 0, len = ref.length; j < len; j++) {
          series = ref[j];
          LineSeries(x0, y0, periodWidth, series, null, lowerChart);
        }
        upperChart = Tag('g', {
          id: 'upper-chart'
        }, root);
      }
      if (this.config.histogram) {
        x0 = chartLeft;
        y0 = topChartBottom;
        priorX = null;
        ref1 = this.config.histogram;
        for (index = k = 0, len1 = ref1.length; k < len1; index = ++k) {
          point = ref1[index];
          x = periodWidth * index + x0;
          if (priorX != null) {
            if (index % 2 === 0) {
              attributes = {
                fill: 'blue'
              };
            } else {
              attributes = {
                fill: 'lightblue'
              };
            }
            if (point != null) {
              Rect(priorX, y0 - point, periodWidth, point, attributes, upperChart);
            }
          }
          priorX = x;
        }
      }
      return this.innerHTML = root;
    }
  }
});
